#!/usr/bin/env groovy


def call(config, scansConfig) {
    stage ('Vulnerability Scans') {
        def stages = [:]
        
        scansConfig.each {
            switch (it.type) {
                case "checkmarx":
                    stages[it.type] = {
                        stage("Checkmarx") {
                            try {
                                notify(config, 'Checkmarx', 'Pending', 'PENDING')
                                checkmarx(config, it)
                                notify(config, 'Checkmarx', 'Successful', 'PENDING')
                            } catch (err) {
                                echo "Caught: ${err}"
                                currentBuild.result = 'UNSTABLE'
                                notify(config, 'Checkmarx', 'Failed', 'FAILURE')
                                error(it.abortOnFailure) // let the vulnerabilityStep know if it should abort
                            }
                        }
                    }
                    break
                case "coverity":
                    stages[it.type] = {
                        stage("Coverity") {
                            try {
                                notify(config, 'Coverity', 'Pending', 'PENDING')
                                coverity(config, it)
                                notify(config, 'Coverity', 'Successful', 'PENDING')
                            } catch (err) {
                                echo "Caught: ${err}"
                                currentBuild.result = 'UNSTABLE'
                                notify(config, 'Coverity', 'Failed', 'FAILURE')
                                error(it.abortOnFailure) // let the vulnerabilityStep know if it should abort
                            }
                        }
                    }
                default:
                    logger("Unable to parse vulnerabilityScans config item: ${it}")
                    break
            }
        }

        parallel(stages)
    }
}