#!/usr/bin/env groovy
import com.ge.nola.BanzaiCfg
import com.ge.nola.BanzaiVulnerabilityCfg

def call(BanzaiCfg cfg, List<BanzaiVulnerabilityCfg> vulnerabilityCfgs) {
    def stages = [:]
    
    vulnerabilityCfgs.each {
        switch (it.type) {
            case "checkmarx":
                stages[it.type] = {
                    stage("Checkmarx") {
                        try {
                            notify(cfg, 'Checkmarx', 'Pending', 'PENDING')
                            checkmarx(cfg, it)
                            notify(cfg, 'Checkmarx', 'Successful', 'PENDING')
                        } catch (err) {
                            echo "Caught: ${err}"
                            currentBuild.result = 'UNSTABLE'
                            notify(cfg, 'Checkmarx', 'Failed', 'FAILURE')
                            def abort = it.abortOnError ? "true" : "false"
                            error(abort) // let the vulnerabilityStage know if it should abort
                        }
                    }
                }
                break
            case "coverity":
                stages[it.type] = {
                    stage("Coverity") {
                        try {
                            notify(cfg, 'Coverity', 'Pending', 'PENDING')
                            coverity(cfg, it)
                            notify(cfg, 'Coverity', 'Successful', 'PENDING')
                        } catch (err) {
                            echo "Caught: ${err}"
                            currentBuild.result = 'UNSTABLE'
                            notify(cfg, 'Coverity', 'Failed', 'FAILURE')
                            def abort = it.abortOnError ? "true" : "false"
                            error(abort) // let the vulnerabilityStage know if it should abort
                        }
                    }
                }
            default:
                logger("Unable to parse vulnerabilityScans cfg item: ${it}")
                break
        }
    }

    parallel(stages)
}